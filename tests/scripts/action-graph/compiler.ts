import path from 'node:path';

import type { ActionGraph, ActionNode, DeterministicAction } from './types.js';
import { ensureDir, writeTextFile } from '../utils/file-operations';

const DEFAULT_FEATURE_DIR = 'tests/features/compiled';
const DEFAULT_STEPS_DIR = 'tests/steps/generated';

interface FeatureOptions {
  includeMetadata?: boolean;
}

export interface CompileActionGraphOptions {
  featureDir?: string;
  stepsDir?: string;
  dryRun?: boolean;
  includeMetadata?: boolean;
}

export interface CompileActionGraphResult {
  featureContent: string;
  stepsContent: string;
  featurePath: string;
  stepsPath: string;
  scenarioSlug: string;
}

export async function compileActionGraph(
  graph: ActionGraph,
  options: CompileActionGraphOptions = {}
): Promise<CompileActionGraphResult> {
  const scenarioSlug = slugify(graph.metadata.scenarioName);
  const featureDir = path.resolve(options.featureDir ?? DEFAULT_FEATURE_DIR);
  const stepsDir = path.resolve(options.stepsDir ?? DEFAULT_STEPS_DIR);
  const featurePath = path.join(featureDir, `${graph.metadata.specId}__${scenarioSlug}.feature`);
  const stepsPath = path.join(stepsDir, `${graph.metadata.specId}__${scenarioSlug}.steps.ts`);

  const featureContent = generateFeatureContent(graph, {
    includeMetadata: options.includeMetadata ?? true,
  });
  const stepsContent = generateStepDefinitions(graph);

  if (!options.dryRun) {
    await ensureDir(path.dirname(featurePath));
    await ensureDir(path.dirname(stepsPath));
    await writeTextFile(featurePath, `${featureContent}\n`);
    await writeTextFile(stepsPath, `${stepsContent}\n`);
  }

  return {
    featureContent,
    stepsContent,
    featurePath,
    stepsPath,
    scenarioSlug,
  };
}

export function generateFeatureContent(graph: ActionGraph, options: FeatureOptions = {}): string {
  const includeMetadata = options.includeMetadata !== false;
  const lines: string[] = [];
  const featureTitle =
    graph.metadata.featureName ?? `Spec ${graph.metadata.specId} scenario ${graph.metadata.scenarioName}`;
  lines.push(`Feature: ${featureTitle}`);

  const description = graph.metadata.authorship?.authoredBy
    ? `Generated by ${graph.metadata.authorship.authoredBy} (${graph.metadata.authorship.authoringMode ? 'authoring' : 'deterministic'})`
    : undefined;
  if (description) {
    lines.push(`  ${description}`);
  }

  const nodes = sortNodes(graph.nodes);
  const backgroundNodes = nodes.filter((node) => isBackgroundNode(node));
  const scenarioNodes = nodes.filter((node) => !isBackgroundNode(node));

  if (backgroundNodes.length > 0) {
    lines.push('');
    lines.push('  Background:');
    for (const node of backgroundNodes) {
      lines.push(formatStepLine(node));
    }
  }

  lines.push('');
  if (graph.metadata.scenarioTags?.length) {
    lines.push(`  ${graph.metadata.scenarioTags.map((tag) => `@${tag}`).join(' ')}`);
  }
  lines.push(`  Scenario: ${graph.metadata.scenarioName}`);
  for (const node of scenarioNodes) {
    lines.push(formatStepLine(node));
  }

  if (includeMetadata) {
    lines.push('');
    lines.push(`# specId: ${graph.metadata.specId}`);
    lines.push(`# graphId: ${graph.graphId}`);
    lines.push(`# generatedAt: ${graph.metadata.createdAt}`);
  }

  return lines.join('\n');
}

export function generateStepDefinitions(graph: ActionGraph): string {
  const nodes = sortNodes(graph.nodes);
  const stepMap = new Map<string, { keyword: 'Given' | 'When' | 'Then'; body: string[] }>();
  let needsExpect = false;

  for (const node of nodes) {
    const text = extractStepText(node);
    const keyword = mapKeywordForNode(node);
    if (!text) {
      continue;
    }

    if (stepMap.has(text)) {
      // Reuse the first deterministic instruction for duplicate text
      continue;
    }

    const { bodyLines, usesExpect } = buildBodyForNode(node);
    needsExpect = needsExpect || usesExpect;
    stepMap.set(text, { keyword, body: bodyLines });
  }

  const lines: string[] = [];
  lines.push(`import { createBdd } from 'playwright-bdd';`);
  if (needsExpect) {
    lines.push(`import { expect } from '@playwright/test';`);
  }
  lines.push('');
  lines.push('const { Given, When, Then } = createBdd();');
  lines.push('');

  for (const [text, definition] of stepMap) {
    lines.push(`${definition.keyword}(${JSON.stringify(text)}, async ({ page }) => {`);
    for (const bodyLine of definition.body) {
      lines.push(`  ${bodyLine}`);
    }
    lines.push('});');
    lines.push('');
  }

  lines.push(
    `// Generated from action graph ${graph.graphId} (spec ${graph.metadata.specId}) on ${new Date().toISOString()}`
  );
  return lines.join('\n').replace(/\n{3,}/g, '\n\n');
}

function sortNodes(nodes: ActionNode[]): ActionNode[] {
  return [...nodes].sort((a, b) => a.stepIndex - b.stepIndex);
}

function isBackgroundNode(node: ActionNode): boolean {
  return node.nodeId.startsWith('bg_');
}

function formatStepLine(node: ActionNode): string {
  const keyword = formatKeyword(node.gherkinStep?.keyword ?? inferKeywordFromType(node.type));
  const text = extractStepText(node) ?? node.nodeId;
  return `    ${keyword} ${text}`;
}

function extractStepText(node: ActionNode): string | undefined {
  return node.gherkinStep?.text ?? node.instructions?.natural ?? undefined;
}

function formatKeyword(keyword: string): string {
  if (!keyword) {
    return 'And';
  }
  return keyword.charAt(0).toUpperCase() + keyword.slice(1).toLowerCase();
}

function mapKeywordForNode(node: ActionNode): 'Given' | 'When' | 'Then' {
  switch (node.type) {
    case 'navigate':
    case 'setup':
      return 'Given';
    case 'assert':
      return 'Then';
    default:
      return 'When';
  }
}

function inferKeywordFromType(type: ActionNode['type']): string {
  switch (type) {
    case 'setup':
    case 'navigate':
      return 'Given';
    case 'assert':
      return 'Then';
    default:
      return 'When';
  }
}

function buildBodyForNode(node: ActionNode): { bodyLines: string[]; usesExpect: boolean } {
  const deterministic = node.instructions?.deterministic;
  const selector = resolveSelector(node);
  const action = deterministic?.action ?? inferActionFromNode(node.type);

  if (!action && node.type !== 'assert') {
    throw new Error(`Node ${node.nodeId} is missing deterministic action`);
  }

  const lines: string[] = [];
  let usesExpect = false;

  const locatorLiteral = selector ? JSON.stringify(selector) : undefined;
  const valueLiteral =
    deterministic?.value !== undefined ? JSON.stringify(String(deterministic.value)) : undefined;

  switch (action as DeterministicAction) {
    case 'navigate': {
      const target = deterministic?.value ?? selector ?? '/';
      lines.push(`await page.goto(${JSON.stringify(String(target))});`);
      break;
    }
    case 'click': {
      assertLocatorAvailable(node.nodeId, locatorLiteral);
      lines.push(`await page.locator(${locatorLiteral}).click();`);
      break;
    }
    case 'fill': {
      assertLocatorAvailable(node.nodeId, locatorLiteral);
      lines.push(
        `await page.locator(${locatorLiteral}).fill(${valueLiteral ?? JSON.stringify('')});`
      );
      break;
    }
    case 'select': {
      assertLocatorAvailable(node.nodeId, locatorLiteral);
      lines.push(
        `await page.locator(${locatorLiteral}).selectOption({ label: ${
          valueLiteral ?? JSON.stringify('')
        } });`
      );
      break;
    }
    case 'check': {
      assertLocatorAvailable(node.nodeId, locatorLiteral);
      const boolLiteral =
        deterministic?.value === undefined
          ? 'true'
          : String(Boolean(deterministic.value as boolean));
      lines.push(`await page.locator(${locatorLiteral}).setChecked(${boolLiteral});`);
      break;
    }
    case 'wait': {
      const timeout = Number(deterministic?.value ?? 1000);
      if (Number.isNaN(timeout)) {
        throw new Error(`Wait node ${node.nodeId} has non-numeric timeout`);
      }
      lines.push(`await page.waitForTimeout(${timeout});`);
      break;
    }
    default: {
      if (node.type === 'assert') {
        assertLocatorAvailable(node.nodeId, locatorLiteral);
        usesExpect = true;
        if (deterministic?.value) {
          lines.push(
            `await expect(page.locator(${locatorLiteral})).toContainText(${JSON.stringify(
              String(deterministic.value)
            )});`
          );
        } else {
          lines.push(`await expect(page.locator(${locatorLiteral})).toBeVisible();`);
        }
        break;
      }
      throw new Error(`Unsupported deterministic action "${action}" on node ${node.nodeId}`);
    }
  }

  return { bodyLines: lines, usesExpect };
}

function inferActionFromNode(type: ActionNode['type']): DeterministicAction | undefined {
  switch (type) {
    case 'setup':
    case 'navigate':
      return 'navigate';
    case 'act':
      return 'click';
    case 'assert':
      return undefined;
    default:
      return undefined;
  }
}

function resolveSelector(node: ActionNode): string | undefined {
  const selectorId = node.instructions?.deterministic?.selector;
  if (selectorId && node.selectors?.length) {
    const match = node.selectors.find((sel) => sel.id === selectorId);
    if (match?.locator) {
      return match.locator;
    }
  }

  if (node.selectors?.length && node.selectors[0].locator) {
    return node.selectors[0].locator;
  }

  if (selectorId) {
    if (/^[#.]/.test(selectorId)) {
      return selectorId;
    }
    return `[data-testid="${selectorId}"]`;
  }

  return undefined;
}

function assertLocatorAvailable(nodeId: string, locatorLiteral?: string): void {
  if (!locatorLiteral) {
    throw new Error(`Deterministic selector missing for node ${nodeId}`);
  }
}

function slugify(value: string): string {
  return value
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '') || 'scenario';
}

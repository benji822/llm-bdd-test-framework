import assert from 'node:assert/strict';
import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import { afterEach, beforeEach, test } from 'node:test';

import { generateFeatureFiles } from '../scripts/generate-features';
import { LLMProvider, type LLMCompletionOptions, type LLMCompletionResult } from '../scripts/llm';

class StubProvider extends LLMProvider {
  readonly name = 'codex' as const;
  public lastPrompt: string | undefined;
  public lastOptions: LLMCompletionOptions | undefined;

  constructor(private readonly response: string) {
    super();
  }

  async generateCompletion(prompt: string, options: LLMCompletionOptions): Promise<LLMCompletionResult> {
    this.lastPrompt = prompt;
    this.lastOptions = options;
    return {
      completion: this.response,
      metadata: {
        provider: 'codex',
        model: options.model,
        tokensUsed: 256,
        responseTime: 640,
      },
    };
  }
}

let tempDir: string;

beforeEach(async () => {
  tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'us2-generate-'));
});

afterEach(async () => {
  delete process.env.LLM_MODEL;
  if (tempDir) {
    await fs.rm(tempDir, { recursive: true, force: true });
  }
});

test('generateFeatureFiles writes sanitized .feature file using vocabulary', async () => {
  const yamlPath = path.join(tempDir, 'normalized/login.yaml');
  const outputDir = path.join(tempDir, 'features');
  const vocabularyPath = path.join(tempDir, 'artifacts/step-vocabulary.json');

  await fs.mkdir(path.dirname(yamlPath), { recursive: true });
  await fs.writeFile(
    yamlPath,
    `feature: Login flows\nscenarios:\n  - name: Successful credential login\n    tags: ['auth']\n    steps:\n      - type: given\n        text: I am on the login page\n      - type: when\n        text: I enter email as "user@example.com"\n      - type: when\n        text: I enter password as "Secret1!"\n      - type: then\n        text: I should see text "Dashboard"\n    selectors:\n      email-input: "input[name='email']"\n      password-input: "input[name='password']"\n      dashboard-text: "h1[role='heading']"\nmetadata:\n  specId: "11111111-1111-1111-1111-111111111111"\n  generatedAt: "2025-10-18T10:30:00Z"\n  llmProvider: "codex"\n  llmModel: "stub-model"\n`,
    'utf8',
  );

  await fs.mkdir(path.dirname(vocabularyPath), { recursive: true });
  await fs.writeFile(
    vocabularyPath,
    JSON.stringify(
      {
        version: '1.0.0',
        lastUpdated: new Date().toISOString(),
        definitions: [
          {
            pattern: 'I am on the {page} page',
            domain: 'navigation',
            file: 'tests/steps/navigation.steps.ts',
            parameters: [{ name: 'page', type: 'string' }],
            examples: ['I am on the login page'],
            version: '1.0.0',
          },
          {
            pattern: 'I enter {field} as {value}',
            domain: 'interaction',
            file: 'tests/steps/interaction.steps.ts',
            parameters: [
              { name: 'field', type: 'string' },
              { name: 'value', type: 'string' },
            ],
            examples: ['I enter email as "user@example.com"'],
            version: '1.0.0',
          },
          {
            pattern: 'I should see text {text}',
            domain: 'assertion',
            file: 'tests/steps/assertion.steps.ts',
            parameters: [{ name: 'text', type: 'string' }],
            examples: ['I should see text "Dashboard"'],
            version: '1.0.0',
          },
        ],
      },
      null,
      2,
    ),
    'utf8',
  );

  const provider = new StubProvider(`Feature: Login flows\n  Ensures credential login behaves as expected\n\n  @auth\n  Scenario: Successful credential login\n    Given I am on the login page\n    When I enter email as "user@example.com"\n    And I enter password as "Secret1!"\n    Then I should see text "Dashboard"`);

  process.env.LLM_MODEL = 'stub-model';
  const result = await generateFeatureFiles({
    yamlPath,
    outputDir,
    provider,
    vocabularyPath,
  });

  const expectedFeaturePath = path.join(outputDir, 'login-flows.feature');
  assert.equal(result.outputPaths[0], expectedFeaturePath);

  const featureContent = await fs.readFile(expectedFeaturePath, 'utf8');
  assert.ok(featureContent.startsWith('Feature: Login flows'));
  assert.ok(!featureContent.includes('```'));
  assert.match(featureContent, /# Generated by codex stub-model/);
  assert.match(featureContent, /I enter email as "<E2E_USER_EMAIL>"/);
  assert.match(featureContent, /I enter password as "<E2E_USER_PASSWORD>"/);
  assert.match(provider.lastPrompt ?? '', /Login flows/);
});

test('generateFeatureFiles rejects when LLM output uses unknown vocabulary step', async () => {
  const yamlPath = path.join(tempDir, 'normalized/logout.yaml');
  const vocabularyPath = path.join(tempDir, 'artifacts/step-vocabulary.json');
  await fs.mkdir(path.dirname(yamlPath), { recursive: true });
  await fs.writeFile(
    yamlPath,
    `feature: Logout\nscenarios:\n  - name: Basic logout\n    steps:\n      - type: given\n        text: I am on the dashboard page\n      - type: when\n        text: I click the logout button\n      - type: then\n        text: I should see text "Signed out"\n    selectors:\n      logout-button: "button[data-testid='logout']"\nmetadata:\n  specId: "22222222-2222-2222-2222-222222222222"\n  generatedAt: "2025-10-18T10:30:00Z"\n  llmProvider: "codex"\n  llmModel: "stub-model"\n`,
    'utf8',
  );

  await fs.mkdir(path.dirname(vocabularyPath), { recursive: true });
  await fs.writeFile(
    vocabularyPath,
    JSON.stringify(
      {
        version: '1.0.0',
        lastUpdated: new Date().toISOString(),
        definitions: [],
      },
      null,
      2,
    ),
    'utf8',
  );

  const provider = new StubProvider(`Feature: Logout\n  Scenario: Basic logout\n    Given I am on the dashboard page\n    When I press the logout icon\n    Then I should see text "Signed out"`);

  await assert.rejects(
    generateFeatureFiles({
      yamlPath,
      outputDir: path.join(tempDir, 'features'),
      provider,
      vocabularyPath,
    }),
    /not covered by vocabulary/i,
  );
});
